### 102. Inheritance

Solidity supports *multiple inheritance*, including *polymorphism*.

1. *Polymorphism* means that a function call (internal and external) always executes the function of the specified name and parameter types in the *most derived contract* in the inheritance hierarchy.
2. When a contract inherits from other contracts, only a *single contract is created* on the blockchain, and the code from all the base contracts is compiled into the created contract.
3. Base functions can be *overriddedn* by inheriting contracts to changed their behavior if they are marked `virtual`. The overriding function must use the `override` keyword in the function header.
4. Languages that allow multiple inheritance must deal with several problems:
    - The *diamond problem*: solidity uses *C3 linearization* to force a specific order in the directed acyclic graph (DAG) of base classes. When a function that is defined multiples times is called, the given bases are searched from right to left (depth-first) to stop at the first match. Python goes left to right.

### 103. Contract Types

In addition to the regular `contract` type, contracts may be marked `abstract contract`, `interface`, or `library`

1. `abstract contract`: at least one function is not implemented
2. `interface`: no functions are implemented. There are further restrictions:
    - cannot inherit from `contract` types, but can from `interface`
    - all declared functions must be `external`
    - cannot declare a `constructor()`
    - cannot declare state variables
3. `library`: deployed once to specific address and code is reused via `DELEGATECALL`
    - when library functions are called, their code is executed in the context of the calling contract

### 104. Using For

The directive `using A for B` can be used to attach functions from the `library A` to any `type(B)` in the context of a `contract`

These functions receive the object (`type(B)`) that they are called on as their first parameter

1. directive is only active within the current contract (including within its functions) and has no effect outside of that contract
2. directive may only be used inside a contract, not inside any of its functions.

> Variables of type uint256 have functions from SafeMath library attached

```solidity
using SafeMath for uint256;
```

### 105. Base Class Functions

It is possible to call functions further up the *inheritance hierarchy*:
- `ContractName.functionName()` explicitly calls the function in another contract (may be a parent, grandparent, etc)
- `super.functionName()` calls the function in the contract one level up

### 106. State Variable Shadowing

This throws an `Error` after `v0.6.0` due to confusion and security concerns with derived variables.

A derived contract may only declare a state variable `x` if there is *no visible state variable* `x` in any of its bases.

### 107. Function Overriding Changes

A function marked `override` in a derived class may:
- redefine the logic of a function in the base class
- alter the *visibility* of a `virtual` function in the base class from `external` to `public`
- change the *mutability* to a more strict one following this order:
    - non-`payable` can be overridden by `view` and `pure`
    - `pure` can be overridden by `pure`
    - `view` can be overridden by `pure`
    - `payable` cannot be overridden

### 108. Virtual Functions

Functions marked `virtual` may **not** define an implementation in the `contract`.

In `interface` types, all functions are automatically considered `virtual` and do not need to be marked so.

`private` functions may **not** be `virtual`

### 109. Public State Variable Override

`public` state variables have automatic getter functions generated by the solidity compiler that return the value of the variable.

The getter function will `override` external functions if their parameter and return types match.

`public` state variables cannot be overriden themselves.

### 110. Modifier Overriding

Function `modifier` types can `override` each other.

This works in the same way as `function` overriding (except that modifiers are not overloaded).

The overriding modifier must be marked `override` and the overriden modifier must be `virtual`.

### 111. Base Constructors

The `constructor()` functions of all base contracts are called with the following *linearization rules*:
- If base constructors *have arguments*, derived contracts must *specify them* (either in inheritance list or in derived constructor)

### 112. Name Collision Error

An `Error` is thrown when any of the following pairs in a contract have the same name due to inheritance:
1. a `function` and a `modifier`
2. a `function` and an `event`
3. an `event` and a `modifier`

### 113. Library Restrictions

In comparison to contracts, libraries are more restricted:
- cannot have state variables
- cannot inherit nor be inherited
- cannot receive Ether
- cannot be destroyed
- can only access state variables of the calling contract if explicitly supplied (has no way to name them otherwise)
- functions can only be called directly (without `DELEGATECALL`) if they do not modify the state (`view` or `pure` functions) because libraries are assumed to be stateless
