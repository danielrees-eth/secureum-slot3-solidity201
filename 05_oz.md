## 147. OpenZeppelin Libraries

OpenZeppelin's smart contract libraries are perhaps the most commonly used libraries in smart contract projects. These include contracts for popular token standards, access control, security, safe math, proxies, and other utilities.

### 148. OZ ERC20

Implements the popular ERC20 token standards.

Its functions include:
1. `constructor(string name_, string symbol_)`
    - sets values for `name_` and `symbol_`. To select a different value for decimals you should overload it. All three of these values are immutable; they can only be set once during construction.
2. `name() returns (string)`
    - returns the name of the token
3. `symbol() returns (string)`
    - returns the symbol of the token, usually a shorter version of the name
4. `decimals() returns (uint8)`
    - returns the number of decimals used to get its user representation.
    - ff `decimals()` is `2`, a balance of `505` tokens is displayed to the user as `5.05` ( 505 / 10**2 )
    - usually set to `18`, mirroring `ether` and `wei`, unless overridden
5. `totalSupply()`
    - returns the amount of tokens in existence
6. `balanceOf(address account) returns (uint256)`
    - returns the amount of tokens owned by an account
7. `transfer(address recipient, uint256 amount) returns (bool)`
    - moves amount tokens from the caller's account to recipient.    
    - Returns a boolean value indicating whether the operation succeeded.
    - Emits a `Transfer` event.
8. `allowance(address owner, address spender) returns (uint256)`
    - returns the remaining number of tokens that *spender* will be allowed to spend on behalf of *owner* through `transferFrom()`
    - set to `0` by default
    - increased via `approve()`
    - decreased when`tranferFrom()` spends owner's tokens
9. `approve(address spender, uint256 amount)`
    - sets *amount* as the *allowance* of *spender* over the caller's tokens.
    - returns `bool` success condition
    - emits `Approval` event
    - WARNING: changing an allowance brings risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this *race condition* is to first reduce the spender's allowance to `0` and set the desired value afterwards.
10. `transferFrom(address spender, uint256 recipient, uint256 amount) returns (bool)`
   - moves *amount* of tokens from *spender* to *recipient*.
   - requires that the caller has sufficient *allowance* to spend *spender's* tokens
   - *amount* is deducted from the caller's *allowance*
   - returns `bool` success condition
   - emits `Transfer` event
11. `increaseAllowance(address spender, uint256 addedValue) returns (bool)`
    - atomically increases *allowance* granted to *spender* by the caller
    - alternative to `approve()`, used to mitigate *race condition* warned above
    - emits `Approval` event indicating the updated *allowance*
    - requires that `spender != address(0)`
12. `decreaseAllowance(address spender, uint256 subtractedValue) returns (bool)`
    - atomically decreases the *allowance* granted to spender by the caller
    - alternative to `approve()`, used to mitigate *race condition* warned above
    - emits `Approval` event indicating updated *allowance*
    - requires that:
         1. `spender != address(0)`
         2. `allowance[spender] >= subtractedValue`

The different extensions and presets are:
1. `ERC20Burnable`
    - extension of `ERC20` that allows token holders to destroy both their own tokens, and those they have an allowance for, in a way that can be recognized off-chain (via `event` analysis)
2. `ERC20Capped`
    - extension of `ERC20` that adds a cap to the supply of tokens and enforces it in the `mint()` function
3. `ERC20Pausable`
    - extension of `ERC20` that may pause token `transfer()`, `mint()`, and `burn()`
4. `ERC20Snapshot`
    - extension of `ERC20` adding a snapshot mechanism
    - when a snapshot is created, the balances and total supply are recorded for later access
    - used to safely create mechanism based on balances, such as trustless dividends or weighted voting
    - the internal `_snapshot()` function creates a snapshot,    
        - emits `Snapshot(uint id)` event
        - returns `currentId`
    - use `totalSupplyAt(uint snapshotId)` to get the total supply at the time of a snapshot
    - use `balanceOfAt(address account, uint snapshotId)` to get the balance of a particular address
5. `ERC20PresetFixedSupply`
    - extension of `ERC20` adding:
        1. a pre-minted `initialSupply`
        2. ability for holders to `burn()` their tokens
        3. no access control mechanism (for minting/pausing) and hence no governance
    - uses `ERC20Burnable` to include burn capabilities
6. `ERC20PresetMinterPauser`
    - extension of `ERC20` adding:
        1. ability for holders to `burn()` their tokens
        2. `MINTER_ROLE` allows for token minting
        3. `PAUSER_ROLE` can stop all token transfers
        4. `DEFAULT_ADMIN_ROLE` may grant both minter and pauser roles to other accounts
    - uses `AccessControl` contract to lock permissioned functions to different roles
    - the account that deploys the contract is granted with all role permissions: minter, pauser, and admin

### 149. OZ SafeERC20

Wrappers around `ERC20` operations that throw an `Error` on failure when the token contract implementation returns `false`.

Tokens that return no value and instead revert or throw on failure are also supported, with non-reverting calls that are assumed to be successful.

Adds functions:
1. `safeTransfer()`
2. `safeTransferFrom()`
3. `safeApprove()`
4. `safeDecreaseAllowance()`
5. `safeIncreaseAllowance()`

### 150. OZ TokenTimelock

A token holder contract that will allow a beneficiary to extract the tokens after a given release time. Useful for simple vesting schedules like "advisors get all their tokens after 1 year."

### 151. OZ ERC721

Implements the popular `ERC721` Non-fungible tokens standard.

Its functions include:
1. `balanceOf(address owner) returns (uin256 balance)`
    - returns the number of tokens in the owner's account
2. `ownerOf(uint256 tokenId) returns (address owner)`
    - returns the owner of the `tokenId` token
    - requires that `tokenId` does exist
3. `transferFrom(address from, address to, uint256 tokenId)`
    - transfers `tokenId` token from `from` to `to`
    - requires that:
        - `from != address(0)`
        - `to != address(0)`
        - `ownerOf(tokenId) == from`
        - if the caller is not `from`, then `tokenId` must be *approved* via either `approve()` or `setApproveForAll()`
    - emits `Transfer` event
4. `safeTransferFrom(address from, address to, uint256 tokenId)`
    - same as `transferFrom()` with additional checks.
    - first checks that contract recipients are aware of the `ERC721` protocol to prevent tokens from being forever locked.
    - additional requirement: if `to` is a contract account, it must implement `IERC721Receiver.onERC721Received()`, which is called upon a safe transfer.
5. `approve(address to, uint256 tokenId)`
    - gives permission to account `to` to `transfer()` a token with `tokenId` to another account
    - approval is cleared when the token is transferred
    - only a single account can be approved at a time, so approving the zero address clears previous approvals
    - requires that:
        - caller must own the token or be *approved*
        - `tokenId` must exist
    - emits `Approval` event
6. `getApproved(uint256 tokenId) returns (address operator)`
    - returns the account approved for `tokenId` token
    - requires that `tokenId` exists
7. `setApprovalForAll(address operator, bool _approved)`
    - approve or remove `operator` as an operator for the caller
    - operators may call `transferFrom()` or `safeTransferFrom()` for any token owned by the caller
    - requires that `operator` is not the caller
    - emits `ApprovedForAll` event
8. `isApprovedForAll(address owner, address operator) returns (bool)`
    - returns `true` if the `operator` is allowed to manage all the assets of the `owner`

The different extensions include:
1. `ERC721Burnable`
    - extension enabling holders to `burn()` tokens
2. `ERC721Enumerable`
    - extension enabling *enumerability* of all token ids in the contract, as well as all token ids owned by each account
3. `ERC721Pausable`
    - extension enabling an admin to *pause* token transfers, minting, and burning
    - useful for scenarios such as preventing trades until the end of an evaluation period, or having an emergency "off" switch in the event of a large bug
4. `ERC721URIStorage`
    - extension enabling storage based token URI management
5. `ERC721PresetMinterPauserAutoId`
    - extension enabling:
        1. ability for holders to `burn()` their tokens
        2. `MINTER_ROLE` allows for token minting
        3. `PAUSER_ROLE` may pause all token transfers
        4. `DEFAULT_ADMIN_ROLE` may grant minter and pauser roles to other accounts
        5. `tokenId` and URI autogeneration
    - uses `AccessControl` to lock permissioned functions using the different roles
    - the account that deploys the contract will be granted the minter, pauser, and admin roles
6. `ERC721Holder`
    - implementation of `IERC721Reciever` interface
    - accepts all token transfers

### 152. OZ ERC777

`ERC777` is similar to `ERC20` in that it defines a standard for fungible tokens.

`ERC777` is backwards compatible with `ERC20` and contains additional improvements including:
- getting rid of confusion around *decimals*
- minting and burning with proper *events*
- receive hooks (the killer feature)

1. A *hook* is a function in a contract that is called when tokens are sent to it, meaning accounts and contracts can *react* to receiving tokens. This enables several use cases including:
    - atomic purchases using tokens (no need for `approve()` and `transferFrom()` in two separate transactions)
    - rejecting reception of tokens (revert on the hook call)
    - redirecting the received tokens to other addresses
2. Both contracts and regular addresses can control and reject which token they send by registering a `tokensToSender` hook (reject by reverting in the hook function)
3. Both contracts and regular addresses can control and reject which token they receive by registering a `tokensReceived` hook (reject by reverting in the hook function)
4. The `tokensReceived` hook allows to send tokens to a contract and notify it in a single transaction, unlike `ERC20` with requires a double call (`approve()` and `transferFrom()` to achieve this)
5. Furthermore, since contracts are required to implement these hooks in order to receive tokens, no tokens can get stuck in a contract that is unaware of the `ERC777` protocol, as has happend countless times when using `ERC20` tokens
6. It mandates that `decimals()` always return `18`, so there is no need for the developer to set it.
7. Has a concept of `defaultOperators` which are special accounts (usually other smart contracts) that will be able to transfer tokens on behalf of their holders
8. Implements `send()` (besides `trnasfer()`) where if the recipient contract has not registered itself as aware of the `ERC777` protocol, then transfers to it are disabled to prevent tokens from being locked forever. Accounts can be notified of tokens being sent to them by having a contract implement this `IERC777Recipient` interface and registering it on the `ERC1820` global registry.

### 153. OZ ERC1155

`ERC1155` is a novel token standard that aims to take the best from previous standards to create a fungibility-agnostic and gas-efficient token contract
1. uses a single smart contract to represent multiple tokens
2. accounts have distinct balance for each token id, and non-fungible tokens are implemented by simply minting a single one of them
3. this approach leads to massive gas savings for project requiring multiple tokens. Instead of deploying a new contract for each token type, a single `ERC1155` token contract can hold the entire system state, reducing both deployment costs and complexity
4. Because all state is held in a single contract, it is possible to operate over multiple tokens in a single transaction very efficiently. The standard provides two functions, `balanceOfBatch()` and `safeBatchTransferFrom()`, that make querying multiple balances and transfering multiple tokens simpler and less gas-intensive

### 154. OZ Ownable

### 155. OZ AccessControl

### 156. OZ Pausable

### 157. OZ ReentrancyGuard

### 158. OZ PullPayment

### 159. OZ Address

### 160. OZ Arrays

### 161. OZ Context

### 162. OZ Counters

### 163. OZ Create2

### 164. OZ Multical

### 165. OZ Strings

### 166. OZ ECDSA

### 167. OZ MerkleProof

### 168. OZ SignatureChecker

### 169. OZ EIP712

### 170. OZ Escrow

### 171. OZ ConditionalEscrow

### 172. OZ RefundEscrow

### 173. OZ ERC165

### 174. OZ Math

### 175. OZ SafeMath

### 176. OZ SignedSafeMath

### 177. OZ SafeCast

### 178. OZ EnumerableMap

### 179. OZ EnumerableSet

### 180. OZ BitMaps

### 181. OZ PaymentSplitter

### 182. OZ TimelockController

### 183. OZ ERC2771Context

### 184. OZ MinimalForwarder

### 185. OZ Proxy

### 186. OZ ERC1967Proxy

### 187. OZ TransparentUpgradableProxy

### 188. OZ ProxyAdmin

### 189. OZ BeaconProxy

### 190. OZ UpgradableBeacon

### 191. OZ Clones

### 192. OZ Initializable
