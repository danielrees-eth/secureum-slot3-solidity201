## 147. OpenZeppelin Libraries

OpenZeppelin's smart contract libraries are perhaps the most commonly used libraries in smart contract projects. These include contracts for popular token standards, access control, security, safe math, proxies, and other utilities.

### 148. OZ ERC20

Implements the popular ERC20 token standards.

Its functions include:
1. `constructor(string name_, string symbol_)`
    - sets values for `name_` and `symbol_`. To select a different value for decimals you should overload it. All three of these values are immutable; they can only be set once during construction.
2. `name() returns (string)`
    - returns the name of the token
3. `symbol() returns (string)`
    - returns the symbol of the token, usually a shorter version of the name
4. `decimals() returns (uint8)`
    - returns the number of decimals used to get its user representation.
    - ff `decimals()` is `2`, a balance of `505` tokens is displayed to the user as `5.05` ( 505 / 10**2 )
    - usually set to `18`, mirroring `ether` and `wei`, unless overridden
5. `totalSupply()`
    - returns the amount of tokens in existence
6. `balanceOf(address account) returns (uint256)`
    - returns the amount of tokens owned by an account
7. `transfer(address recipient, uint256 amount) returns (bool)`
    - moves amount tokens from the caller's account to recipient.    
    - Returns a boolean value indicating whether the operation succeeded.
    - Emits a `Transfer` event.
8. `allowance(address owner, address spender) returns (uint256)`
    - returns the remaining number of tokens that *spender* will be allowed to spend on behalf of *owner* through `transferFrom()`
    - set to `0` by default
    - increased via `approve()`
    - decreased when`tranferFrom()` spends owner's tokens
9. `approve(address spender, uint256 amount)`
    - sets *amount* as the *allowance* of *spender* over the caller's tokens.
    - returns `bool` success condition
    - emits `Approval` event
    - WARNING: changing an allowance brings risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this *race condition* is to first reduce the spender's allowance to `0` and set the desired value afterwards.
10. `transferFrom(address spender, uint256 recipient, uint256 amount) returns (bool)`
   - moves *amount* of tokens from *spender* to *recipient*.
   - requires that the caller has sufficient *allowance* to spend *spender's* tokens
   - *amount* is deducted from the caller's *allowance*
   - returns `bool` success condition
   - emits `Transfer` event
11. `increaseAllowance(address spender, uint256 addedValue) returns (bool)`
    - atomically increases *allowance* granted to *spender* by the caller
    - alternative to `approve()`, used to mitigate *race condition* warned above
    - emits `Approval` event indicating the updated *allowance*
    - requires that `spender != address(0)`
12. `decreaseAllowance(address spender, uint256 subtractedValue) returns (bool)`
    - atomically decreases the *allowance* granted to spender by the caller
    - alternative to `approve()`, used to mitigate *race condition* warned above
    - emits `Approval` event indicating updated *allowance*
    - requires that:
         1. `spender != address(0)`
         2. `allowance[spender] >= subtractedValue`

The different extensions and presets are:
1. `ERC20Burnable`
    - extension of `ERC20` that allows token holders to destroy both their own tokens, and those they have an allowance for, in a way that can be recognized off-chain (via `event` analysis)
2. `ERC20Capped`
    - extension of `ERC20` that adds a cap to the supply of tokens and enforces it in the `mint()` function
3. `ERC20Pausable`
    - extension of `ERC20` that may pause token `transfer()`, `mint()`, and `burn()`
4. `ERC20Snapshot`
    - extension of `ERC20` adding a snapshot mechanism
    - when a snapshot is created, the balances and total supply are recorded for later access
    - used to safely create mechanism based on balances, such as trustless dividends or weighted voting
    - the internal `_snapshot()` function creates a snapshot,    
        - emits `Snapshot(uint id)` event
        - returns `currentId`
    - use `totalSupplyAt(uint snapshotId)` to get the total supply at the time of a snapshot
    - use `balanceOfAt(address account, uint snapshotId)` to get the balance of a particular address
5. `ERC20PresetFixedSupply`
    - extension of `ERC20` adding:
        1. a pre-minted `initialSupply`
        2. ability for holders to `burn()` their tokens
        3. no access control mechanism (for minting/pausing) and hence no governance
    - uses `ERC20Burnable` to include burn capabilities
6. `ERC20PresetMinterPauser`
    - extension of `ERC20` adding:
        1. ability for holders to `burn()` their tokens
        2. `MINTER_ROLE` allows for token minting
        3. `PAUSER_ROLE` can stop all token transfers
        4. `DEFAULT_ADMIN_ROLE` may grant both minter and pauser roles to other accounts
    - uses `AccessControl` contract to lock permissioned functions to different roles
    - the account that deploys the contract is granted with all role permissions: minter, pauser, and admin

### 149. OZ SafeERC20

Wrappers around `ERC20` operations that throw an `Error` on failure when the token contract implementation returns `false`.

Tokens that return no value and instead revert or throw on failure are also supported, with non-reverting calls that are assumed to be successful.

Adds functions:
1. `safeTransfer()`
2. `safeTransferFrom()`
3. `safeApprove()`
4. `safeDecreaseAllowance()`
5. `safeIncreaseAllowance()`

### 150. OZ TokenTimelock

### 151. OZ ERC721

### 152. OZ ERC777

### 153. OZ ERC1155

### 154. OZ Ownable

### 155. OZ AccessControl

### 156. OZ Pausable

### 157. OZ ReentrancyGuard

### 158. OZ PullPayment

### 159. OZ Address

### 160. OZ Arrays

### 161. OZ Context

### 162. OZ Counters

### 163. OZ Create2

### 164. OZ Multical

### 165. OZ Strings

### 166. OZ ECDSA

### 167. OZ MerkleProof

### 168. OZ SignatureChecker

### 169. OZ EIP712

### 170. OZ Escrow

### 171. OZ ConditionalEscrow

### 172. OZ RefundEscrow

### 173. OZ ERC165

### 174. OZ Math

### 175. OZ SafeMath

### 176. OZ SignedSafeMath

### 177. OZ SafeCast

### 178. OZ EnumerableMap

### 179. OZ EnumerableSet

### 180. OZ BitMaps

### 181. OZ PaymentSplitter

### 182. OZ TimelockController

### 183. OZ ERC2771Context

### 184. OZ MinimalForwarder

### 185. OZ Proxy

### 186. OZ ERC1967Proxy

### 187. OZ TransparentUpgradableProxy

### 188. OZ ProxyAdmin

### 189. OZ BeaconProxy

### 190. OZ UpgradableBeacon

### 191. OZ Clones

### 192. OZ Initializable
