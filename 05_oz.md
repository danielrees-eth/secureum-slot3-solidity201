## 147. OpenZeppelin Libraries

OpenZeppelin's smart contract libraries are perhaps the most commonly used libraries in smart contract projects.

These include contracts for popular token standards, access control, security, safe math, proxies, and other utilities.

### 148. OZ ERC20

Implements the popular `ERC20` token standards.

Its functions include:
1. `constructor(string name_, string symbol_)`
    - sets values for `name_` and `symbol_`
    - select a different value for `decimals_` by including it as a third parameter
    - all three of these values are `immutable`; they can only be set once during construction
2. `name() returns (string)`
    - returns the `name_` of the token
3. `symbol() returns (string)`
    - returns the `symbol_` of the token
    - usually a `symbol_` is a shorter version of the `name_`
4. `decimals() returns (uint8)`
    - returns the number of `decimals_` used to get its user representation.
    - If `decimals_ = 2`, then a balance of `505` tokens is displayed as `5.05` ( 505 / 10**2 )
    - usually it is set to `18`, mirroring `ether` and `wei`, unless overridden
5. `totalSupply()`
    - returns the amount of tokens in existence
6. `balanceOf(address account) returns (uint256)`
    - returns the amount of tokens owned by an account
7. `transfer(address recipient, uint256 amount) returns (bool)`
    - moves amount tokens from the caller's account to recipient   
    - returns a `bool` success condition
    - emits a `Transfer` event
8. `allowance(address owner, address spender) returns (uint256)`
    - returns the number of tokens that `spender` is allowed spend on behalf of `owner` through `transferFrom()`
    - default is `0`
    - increased via `approve()`
    - decreased when`transferFrom()` spends owner's tokens
9. `approve(address spender, uint256 amount)`
    - sets `amount` as the **allowance** of `spender` over the tokens of `msg.sender`
    - returns `bool` success condition
    - emits `Approval` event
    - **WARNING**: changing an allowance brings risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this *race condition* is to first reduce the spender's allowance to `0` and set the desired value afterwards.
10. `transferFrom(address spender, uint256 recipient, uint256 amount) returns (bool)`
   - moves `amount` of tokens from `spender` to `recipient`.
   - requires that `msg.sender` has sufficient *allowance* approved for the tokens of `spender`
   - `amount` is deducted from the `msg.sender` *allowance*
   - returns `bool` success condition
   - emits `Transfer` event
11. `increaseAllowance(address spender, uint256 addedValue) returns (bool)`
    - atomically increases *allowance* granted to `spender` by `msg.sender`
    - alternative to `approve()`, used to mitigate *race condition* warned above
    - emits `Approval` event
    - requires that `spender != address(0)`
12. `decreaseAllowance(address spender, uint256 subtractedValue) returns (bool)`
    - atomically decreases the *allowance* granted to `spender` by `msg.sender`
    - alternative to `approve()`, used to mitigate *race condition* warned above
    - emits `Approval` event
    - requires that:
         1. `spender != address(0)`
         2. `allowance[spender] >= subtractedValue`

The different extensions and presets are:
1. `ERC20Burnable`
    - extension of `ERC20` that allows token holders to `burn()` both their own tokens, and those they have an allowance for, in a way that can be recognized off-chain (via `event` analysis)
2. `ERC20Capped`
    - extension of `ERC20` with a **capped supply** of tokens, enforced in the `mint()` function
3. `ERC20Pausable`
    - extension of `ERC20` that may **pause** token `transfer()`, `mint()`, and `burn()`
4. `ERC20Snapshot`
    - extension of `ERC20` adding a **snapshot mechanism**
    - token *balances* and *total supply* are **recorded** in periodic snapshots for later access
    - used to safely create mechanisms based on balances, such as trustless dividends or weighted voting
    - the internal `_snapshot()` function creates a snapshot,    
        - emits `Snapshot(uint id)` event
        - returns `currentId`
    - use `totalSupplyAt(uint snapshotId)` to get the total supply at the time of a snapshot
    - use `balanceOfAt(address account, uint snapshotId)` to get the balance of a particular address
5. `ERC20PresetFixedSupply`
    - extension of `ERC20` adding:
        1. a pre-minted `initialSupply`
        2. ability for holders to `burn()` their tokens
        3. **no access control mechanism** (for minting/pausing) and hence no governance
    - uses `ERC20Burnable` to include burn capabilities
6. `ERC20PresetMinterPauser`
    - extension of `ERC20` adding:
        1. ability for holders to `burn()` their tokens
        2. `MINTER_ROLE` allows for token minting
        3. `PAUSER_ROLE` can stop all token transfers
        4. `DEFAULT_ADMIN_ROLE` may grant both minter and pauser roles to other accounts
    - uses `AccessControl` contract to lock permissioned functions to different roles
    - the account that deploys the contract is granted with all role permissions: minter, pauser, and admin

### 149. OZ SafeERC20

Wrappers around `ERC20` operations that throw an `Error` on failure when the token contract implementation returns `false`.

Tokens that return no value and instead revert or throw on failure are also supported, with non-reverting calls that are assumed to be successful.

Adds functions:
1. `safeTransfer()`
2. `safeTransferFrom()`
3. `safeApprove()`
4. `safeDecreaseAllowance()`
5. `safeIncreaseAllowance()`

### 150. OZ TokenTimelock

A token holder contract that will allow a beneficiary to extract the tokens after a given release time.

Useful for simple vesting schedules like "advisors get all their tokens after 1 year."

### 151. OZ ERC721

Implements the popular `ERC721` Non-fungible tokens standard.

Its functions include:
1. `balanceOf(address owner) returns (uin256 balance)`
    - returns the `balance` of tokens belonging to `owner`
2. `ownerOf(uint256 tokenId) returns (address owner)`
    - returns the `owner` of the token with `tokenId`
    - requires that `tokenId` exists
3. `transferFrom(address from, address to, uint256 tokenId)`
    - transfers `tokenId` token from `from` to `to`
    - requires that:
        - `from != address(0)`
        - `to != address(0)`
        - `ownerOf(tokenId) == from`
        - if `msg.sender != from`, then `tokenId` must be *approved* via either `approve()` or `setApproveForAll()`
    - emits `Transfer` event
4. `safeTransferFrom(address from, address to, uint256 tokenId)`
    - same as `transferFrom()` with additional checks:
        - contract recipients must be aware of the `ERC721` protocol to prevent tokens from being forever locked
        - if `to` is a contract account, it must implement `IERC721Receiver.onERC721Received()`, which is called upon a safe transfer.
5. `approve(address to, uint256 tokenId)`
    - gives permission to `to` to `transfer()` the token with `tokenId` to another account
    - approval is removed after the token is transferred (set to `address(0)`)
    - only a single account can be approved at a time
    - requires that:
        - `msg.sender` must either own the token or be *approved*
        - `tokenId` must exist
    - emits `Approval` event
6. `getApproved(uint256 tokenId) returns (address operator)`
    - returns the account `operator` approved for the token with `tokenId`
    - `tokenId` must exist
7. `setApprovalForAll(address operator, bool _approved)`
    - approve or remove `operator` as an operator for `msg.sender`
    - operators may call `transferFrom()` or `safeTransferFrom()` for any token owned by `msg.sender`
    - requires that `operator != msg.sender`
    - emits `ApprovedForAll` event
8. `isApprovedForAll(address owner, address operator) returns (bool)`
    - returns `true` if the `operator` is allowed to manage all the assets of the `owner`

The different extensions include:
1. `ERC721Burnable`
    - extension enabling holders to `burn()` tokens
2. `ERC721Enumerable`
    - extension enabling **enumerability** of all token ids in the contract
    - may also enumerate all token ids owned by each account
3. `ERC721Pausable`
    - extension enabling an admin to **pause** token `transfer()`, `mint()`, and `burn()`
    - useful for scenarios such as:
        - preventing trades until the end of an evaluation period
        - having an emergency "off" switch in the event of a large bug
4. `ERC721URIStorage`
    - extension enabling **storage based token URI management**
5. `ERC721PresetMinterPauserAutoId`
    - extension enabling:
        1. ability for holders to `burn()` their tokens
        2. `MINTER_ROLE` allows for token minting
        3. `PAUSER_ROLE` may pause all token transfers
        4. `DEFAULT_ADMIN_ROLE` may grant minter and pauser roles to other accounts
        5. `tokenId` and URI autogeneration
    - uses `AccessControl` to lock permissioned functions using the different roles
    - the account that deploys the contract will be granted the minter, pauser, and admin roles
6. `ERC721Holder`
    - implementation of `IERC721Reciever` interface
    - accepts all token transfers

### 152. OZ ERC777

`ERC777` is similar to `ERC20` in that it defines a standard for fungible tokens.

`ERC777` is backwards compatible with `ERC20` and contains additional improvements including:
- clarifying confusion around `decimals`
- proper **events** for minting and burning
- **receive hooks** (the killer feature)

1. A **hook** is a function in a contract that is called when tokens are sent to it, meaning both EOAs and contracts can *react* to receiving tokens. This enables several use cases including:
    - **atomic purchases** using tokens (no need for `approve()` and `transferFrom()` in two separate transactions)
    - **rejecting reception** of tokens (revert on the hook call)
    - **redirecting received tokens** to other addresses
2. `tokensToSender` hook lets accounts register **which tokens they may send** to others (rejects by reverting in the hook function)
3. `tokensReceived` hook lets accounts register **which tokens they may receive** from others (rejects by reverting in the hook function)
4. `tokensReceived` hook allows to send tokens to a contract and notify it in a single transaction, unlike `ERC20` with requires a double call (`approve()`, then `transferFrom()`)
5. No tokens can get stuck in a contract that is unaware of the `ERC777` protocol, as is common with `ERC20` tokens, because accounts must implement these hooks to receive them
6. `decimals()` must be `18`; there is no need for the developer to set it
7. `defaultOperators` are special accounts (usually other smart contracts) that will be able to transfer tokens on behalf of their holders
8. if a recipient contract is not registered as aware of the `ERC777` protocol, then transfers (via `send()`) to it are disabled, preventing the tokens from being locked forever.
    - contracts must implement `IERC777Recipient` interface and register it on the `ERC1820` global registry.

### 153. OZ ERC1155

`ERC1155` is a novel token standard that aims to take the best from previous standards to create a **fungibility-agnostic** and **gas-efficient** token contract
1. uses a single smart contract to **represent multiple token**
2. accounts have distinct **balance for each token id**, and non-fungible tokens are implemented by simply minting a single one of them
3. this approach leads to **massive gas savings** for project requiring multiple tokens.
    - instead of deploying a new contract for each token type, a single `ERC1155` token contract can hold the entire system state, reducing both deployment costs and complexity
4. Because all state is held in a single contract, it is possible to operate over multiple tokens in a single transaction very efficiently
    - `balanceOfBatch()` and `safeBatchTransferFrom()` make querying multiple balances and transferring multiple tokens simpler and less gas-intensive

### 154. OZ Ownable

Provides basic **access control mechanism** where the contract `owner` can be granted exclusive access to specific functions.
- by default, the `owner` is the account that deploys the contract.
- `owner` can be changed via `transferOwnership(address newOwner)`
- used through inheritance
- makes the modifier `onlyOwner` available to restrict function access to the `owner`

### 155. OZ AccessControl

Provides a general **role-based access control mechanism**
- **multiple hierarchical roles** can be created and **assigned to multiple accounts**
- roles can be used to represent a **set of permissions**
- `hasRole` is used to restrict access to a function call
- roles are granted and revoked via the `grantRole` and `revokeRole` functions, which can only be called by the role's associated admin accounts

While the simplicity of `Ownable` is useful for simple systems or quick prototyping, different levels of authorization are often needed via `AccessControl`.

You may want for an account to have permission to ban users from a system, but not create new tokens. Role-Based Access Control (RBAC) offers flexibility in this regard.

We will effectively be defining multiple roles, each allowed to perform different sets of actions.

An account may have, for example, "moderator", "minter", or "admin" roles, which can each be checked for. Separately, you will be able to define rules for how accounts can be granted a role, have it revoked, and more.

`AccessControlEnumerable` extends `AccessControl`, allowing enumerating the members of each role.

### 156. OZ Pausable

Provides an **emergency stop mechanism** using functions `pause()` and `unpause()` that can be triggered by an authorized account.
- used through inheritance.
- makes available modifiers `whenNotPaused` and `whenPaused`
- only functions using these modifiers are affected when contract is paused or unpaused.

### 157. OZ ReentrancyGuard

**Prevents reentrant calls** to a functions.
- used through inheritance
- makes `nonReentrant` modifier available
- functions with this modifier will revert upon receiving a nested (reentrant) call

### 158. OZ PullPayment

Provides a pull-payment strategy, where the **paying contract doesn't invoke any functions on the receiver account**
- **receiving account must withdraw** its payments itself.
- considered a best practice for sending Ether, security wise
- prevents recipients from blocking execution
- eliminates reentrancy concerns

### 159. OZ Address

The `Address` library is a collection of functions related to the `address` type:
1. `isContract(address account) returns (bool)`
    - returns `true` if account is a `contract`
    - unsafe to assume that an `address` returning `false` is an EOA (not a contract)
    - among others, returns `false` for:
        1. an EOA
        2. contract in construction
        3. address where a contract will be created
        4. address where contract lived, but was destroyed
2. `sendValue(address payable recipient, uint256 amount)`
    - replacement for `transfer()`
        - sends `amount` of wei to `recipient`
        - forwards all available gas
        - reverts on errors
    - `EIP-1884` increased the gas cost of certain opcodes, possibly making contracts go over the 2300 gas limit imposed by `transfer()` and thus unable to receive funds
    - `sendValue` removes the limitation noted above
3. `functionCall(address target, bytes data) returns (bytes)`
    - low-level function call
    - A plain `call()` is an unsafe replacement for a function call: use `functionCall()` instead.
    - if the `target` function reverts with a reason string, it is bubbled up by `functionCall()` (like regular function calls)
    - returns raw returned `data`
    - requires that:
        - `target` must be a contract
        - calling `target` with `data` **must not revert**
4. `functionCallWithValue(address target, bytes data, uint256 value) returns (bytes)`
    - same as `functionCall()`, but also **transfers** `value` of wei to `target`
    - requires that:
        1. calling contract `C` must have `address(C).balance >= value`
        2. called `function` must be `payable`
5. `functionStaticCall(address target, bytes data) returns (bytes)`
    - same as `functionCall()`, but performing a static call
6. `functionDelegateCall(address target, bytes data) returns (bytes)`
    - same as `functionCall()`, but performing a delegate call

The above `functionCall*` functions have variants which pass an `errorMessage` parameter that specifies the fallback `revert` reason when the target reverts.

### 160. OZ Arrays

Collection of functions related to array types.
- `findUpperBound(uint[] array, uint element) returns (uint)`
    - seaches a sorted `array` for `element`
    - returns the first index `i` where `array[i] >= element`
    - if no such `i` exists, then returns `array.length`
    - time complexity: **O(log n)**
    - `array` must be sorted in **ascending order** with **no repeated elements**

### 161. OZ Context

Provides information about the current execution context, including the **sender of a transaction** and **its data**.
- These are generally available via `msg.sender` and `msg.data`, they should not be accessed directly.
- Dealing with meta-transactions, the account sending and paying for execution may not be the actual sender (as far as an application is concerned)
- Only required for intermediate, library-like contracts

### 162. OZ Counters

Provides counters that can only be incremented or decremented by one.

- used to:
    - track the number of elements in a mapping
    - issue ERC721 ids
    - count request ids.
- functions are:
    1. `current(struct Counters.Counter counter) returns (uint)`
    2. `increment(struct Counters.Counter counter)`
    3. `decrement(struct Counters.Counter counter)`

### 163. OZ Create2

Makes use of `CREATE2` EVM opcode easier and safer.

`CREATE2` can be used to compute the address where a smart contract will be deployed in advance, allowing for new mechanisms known as **counterfactual interactions**

1. `deploy(uint amount, bytes32 salt, bytes bytecode) returns (address)`
    - deploys a contract using `CREATE2`
    - address of deployment can be known in advance via `computeAddress()`
    - bytecode for contract can be obtained with `type(contractName).creationCode`
    - requires that:
        - `bytecode` is not empty
        - `salt` must have not been used for `bytecode` already
        - *factory* must have a balance of at least `amount`
        - if `amount` is non-zero, `bytecode` must have a `payable` constructor
2. `computeAddress(bytes32 salt, bytes32 bytecodeHash) returns (address)`
    - returns the `address` where a `contract` will be stored if deployed via `deploy()`
    - any change in `bytecodeHash` or `salt` results in a new destination address
3. `computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) returns (address)`
    - returns the `address` where a `contract` will be stored if deployed via `deploy()` from a contract located at `deployer`
    - if the `deployer` is this contract's address, it returns the same value as the `computeAddress()` method above

### 164. OZ Multicall

Provides a function to batch together multiple calls in a single external call.
1. `multicall(bytes[] calldata data) external returns (bytes[])`
    - receives and executes a **batch of function calls** on this contract

### 165. OZ Strings

String operations:
1. `toString(uint value) returns (string)`
    - converts a `uint256` to its ASCII `string` **decimal representation**
2. `toHexString(uint value) returns (string)`
    - converts a `uint256` to its ASCII `string` **hexadecimal representation**
3. `toHexString(uint value, uint length) returns (string)`
    - converts a `uint256` to its ASCII `string` **hexadecimal representation with fixed length**

### 166. OZ ECDSA

Provides functions for **recovering and managing Ethereum account ECDSA signatures**.

These are often generated via `web3.eth.sign` and are a 65 byte array (of type `bytes` in Solidity) arranged the following way: `[ [v(1)], [r(32)], [s(32)] ]`

The data signer can be recovered with `ECDSA.recover`, and its `address` compared to verify the signature.

Most wallets will hash the data to sign and add the prefix `\x19Ethereum Signed Message:\n`, so when attempting to recover the signer of an Ethereum signed message hash, you'll want to use `toEthSignedMessageHash`

The `ecrecover` EVM opcode allows for malleable (non-unique) signatures. This library prevents **signature malleability** by requiring `s` value to be in the lower half order, and the `v` value to either be  `27` or `28`

### 167. OZ MerkleProof

Deals with **verification of Merkle Trees proofs**
1. `verify()`
    - can prove that some value is part of a merkle tree
    - returns `true` if a "leaf" can be proved to be a part of a Merkle tree defined by "root"
        - a "proof" must be provided containing sibling hashes on the branch from the leaf to the root of the tree.
    - each pair of leaves and each pair of pre-images are assumed to be sorted.

### 168. OZ SignatureChecker

Provides a single mechanism to **verify** both **private-key (EOA) ECDSA signatures** and **ERC1271 contract signatures**.

Using this instead of `ECDSA.recover` in your contract will make them **compatible with smart contract wallets** such as Argent and Gnosis.

Externally Owned Accounts (EOAs) can sign messages with their private keys, but contracts do not have private keys. This is a problem for many applications requiring off-chain signatures. `ERC1271` proposes a standard for contracts to verify whether a signature on behalf of a given contract is valid.

Unlike ECDSA signatures, a contract signature is revocable and may change through time. It could return `true` at block `N` and `false` at block `N+1`.

### 169. OZ EIP712

`EIP712` is a standard for **hashing and signing** of **types structured data**.

This contract implements the `EIP712` domain separator `_domainSeparatorV4` that is used as part of the encoding scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA `_hashTypedDataV4`.

Protocols need to implement the type specific encoding they need in their contracts using a combination of `abi.encode` and `keccak256`.

1. `constructor(string name, string version)`
    - initializes the domain separator and parameter caches
    - the meaning of `name` and `version` is specified in `EIP712:1`
        - `name` is the human readable name of the signing domain (name of dapp or protocol)
        - `version` is the current major version of the signing domain
2. `_domainSeparatorV4() returns (bytes32)`
    - returns the domain separator for the current chain
    - `_hashTypedDataV4(bytes32 structHash) returns (bytes32)`
        - given a hashed struct, returns the hash of the fully encoded `EIP712` message for this domain
        - the hash can be used together with `ECDSA.recover` to obtain the signer of a message

### 170. OZ Escrow

Holds funds designated for a payee until they withdraw them.

The contract that uses this escrow as its payment methods should be its owner, and provide public methods redirecting the escrow's deposit and withdraw if the escrow rules are satisfied.

Its functions include:
1. `depositsOf(address payee) returns (uint256)`
2. `deposit(address payee)`
    - stores the send amount as credit to be withdrawn
3. `withdraw(address payable payee)`
    - withdraws accumulated balance for a payee
    - forwards all gas to recipient

### 171. OZ ConditionalEscrow

Derived from `Escrow`.
- only allows withdrawal if a specified conditions are met
- `withdrawalAllowed()` returns whether an address is allowed to withdraw their funds, and is to be implemented by derived contracts

### 172. OZ RefundEscrow

Derived from `ConditionalEscrow`
- holds funds for a beneficiary, deposited from multiple parties
- owner of this contract may:
    - deposit
    - close deposit period
    - allow for either withdrawal by beneficiary or refunds to depositors

### 173. OZ ERC165

`ERC165` is a standard that helps detect whether runtime interfaces are supported by a given contract.

Interfaces are:
- registered via `_registerInterface(bytes4)`
- detected via `_supportsInterface(bytes4 interfaceId)`

### 174. OZ Math

Standard math utilities that are missing in the Solidity language
1. `max(uint256 a, uint256 b)`
    - returns the larger of two numbers
2. `min(uint256 a, uint256 b)`
    - returns the smaller of two numbers
3. `average(uint256 a, uint256 b)`
    - returns the average of two numbers
    - result is rounded towards zero

### 175. OZ SafeMath

Provides mathematical functions that protect your contract from overflows and underflows.

Include within a contract via:
```Solidity
using SafeMath for uint256;
```

Then safemath functions are available as members of the `uint256` type:
1. `add(uint256 otherNum)`
    - returns addition of two unsigned integers
    - reverts on overflow
    - counterpart to `+` operator
2. `sub(uint256 otherNum)`
    - returns subtraction of two unsigned integers
    - reverts on overflow
    - counterpart to `-` operator
3. `div(uint256 otherNum)`
    - returns division of two unsigned integers
    - reverts on overflow
    - reverts when dividing by zero???
    - result is rounded towards zero
    - counterpart to `/` operator
4. `mul(uint256 otherNum)`
    - returns multiplication of two unsigned integers
    - reverts on overflow
    - counterpart to `*` operator
5. `mod(uint256 otherNum)`
    - returns modulus of two unsigned integers
    - reverts when dividing by zero
     counterpart to `%` operator

The corresponding `try*` functions return results with an overflow flag instead of reverting.

### 176. OZ SignedSafeMath

Provides the same functions as `SafeMath` but for **signed integers**

1. `add(int256 otherNum)`
2. `sub(int256 otherNum)`
3. `div(int256 otherNum)`
4. `mul(int256 otherNum)`

### 177. OZ SafeCast

Wrappers over `uintN` or `intN` casting operators with added overflow checks.

Downcasting types does not revert on overflow in Solidity, resulting in bugs because developers usually assume that overflow raised errors.

`SafeCase` restores this intuition by reverting the transaction when such an operation overflows.

1. `toUint128(uint256 value) returns (uint128)`
    - downcast `uint256` to `uint128`
2. `toInt128(int256 value) internal pure returns (uint256)`
    - downcast `int256` to `int128`
3. `toInt256(uint256 value) returns (int256)`
    - convert `uint256` to `int256`
4. `toUint256(int256 value) returns (uint256)`
    - convert `int256` to `uint267`
5. similar functions downcasting to 244/96/64/32/16/8 bits, for both unsigned and signed integers

### 178. OZ EnumerableMap

Library for managing an enumerable variant of Solidity's mapping type.

Maps have the following properties:
1. entries are added, removed, and checked for existence in constant time (O(1))
2. entries are enumerated in O(n) time, but no garuntees are made on the ordering

As of `v3.0.0`, only maps of type `uint256 => address` are supported

Functions include:
1. `set(struct EnumerableMap.UintToAddressMap map, uint256 key, address value) returns (bool)`
    - adds a key-value pair to a map, or updates value of existing key
    - returns `true` if the key was added to the map (not already present)
    - returns `false` if the key value was updated (already present)
2. `remove(struct EnumerableMap.UintToAddressMap map, uint256 key) returns (bool)`
    - removes a value from a set
    - returns `true` if key was removed from the map (it was already present)
3. `contains(struct EnumerableMap.UintToAddressMap map, uint256 key) returns (bool)`
    - returns `true` if the key is in the map
4. `length(struct EnumerableMpa.UintToAddressMap map) returns (uint256)`
    - returns the number of elements in the map
5. `at(struct EnumerableMap.UintToAddressMap map, uint256 index) returns (uint256, address)`
    - returns the element stored at position `index` in the set
    - there are no guarantees on the ordering of values in a map, and it may changes when values are added or removed
    - requires that index is strictly less than length
6. `tryGet(struct EnumerableMap.UintToAddressMap map, uint256 key) returns (bool, address)`
    - tries to return the value associated with key
    - does not revert if key is not in the map
7. `get(struct EnumerableMap.UintToAddressMap map, uint256 key) returns (address)`
    - returns the value associated with key
    - requirest that the key must be in the map

### 179. OZ EnumerableSet

Library for managing sets of primitive types.

Sets have the following properties:
1. Elements are added, removed, and checked for existence in constant time (O(1))
2. Elements are enumerated in O(n)
3. No guarantees are mode on the ordering of elements

As of `v3.3.0`, sets of types `bytes32`, `address`, and `uint256` are supported: `Bytes32Set`, `AddressSet`, and `UintSet` respectively

Functions include:
1. `add(struct EnumerableSet.Bytes32Set set, bytes32 value) returns (bool)`
    - add a value to a set
    - returns `true` if `value` was added to set (it was not already present)
2. `remove(struct EnumerableSet.Bytes32Set set, bytes32 value) returns (bool)`
    - removes a value from a set
    - returns `true` if the value was removed from the set (it was not already present)
3. `contains(struct EnumerableSet.Bytes32Set set, bytes32 value) returns (bool)`
    - returns `true` if the value is in the set
4. `length(struct EnumerableSet.Bytes32Set set) returns (bool)`
    - returns the number of values in the set
5. `at(struct EnumerableSet.Bytes32Set set, uint256 index) returns (bytes32)`
    - returns the value stored at position `index` in the set
    - there is no guarantee on the ordering of values in the set, and it may change when values are added or removed
    - requires that index must be strictly less than length
6. similar functions for `AddressSet` and `UintSet` types

### 180. OZ BitMaps

Library for managing `uint256` to `bool` mapping in a compact and efficient way, providing the keys are sequential
1. `struct BitMap: mapping(uint256 => uint256) _data;`???
2. `get(BitMap storage bitmap, uint256 index) returns (bool)`
    - returns whether the bit at `index` is set
3. `setTo(BitMap storage bitmap, uint256 index, bool value)`
    - sets the bit at `index` to the boolean `value`
4. `set(BitMap storage bitmap, uint256 index)`
    - sets the bit at `index`
5. `uinset(BitMap storage bitmap, uint256 index)`
    - unsets the bit at `index`

### 181. OZ PaymentSplitter

Allows to split Ether payments among a group of accounts.

The sender does not need to be aware that the Ether will be split, because it is handled transparently by the contract.

The split can be in equal parts, or in any other arbitrary proportion. This is specified by assigning each account to a number of shares.

Of all the Ether that this contract receives, each account will then be able to clain an amount proportional to the percentage of total shares they were assigned.

`PaymentSplitter` follows a pull-payment model. Ether is not automatically forwarded to the accounts, but is held in the contract and must be withdrawn by recipients.

### 182. OZ TimelockController

Acts as a timelocked controller.

When set as the owner of an `Ownable` smart contract, it enforces a timelock on all `onlyOwner` maintenance operations.  This gives time for users of the controlled contract to exit before a potentially dangerous maintenance operation is applied.

By default, this contract is self-administered, meaning administraction tasks have to go through a timelock process.

THe proposer (resp executor) role is in charge of proposing (resp executing) operations.

A common use case is to position this `TimelockController` as the owner of a smart contract, with a multisig or a DAO as the sole proposer.

Functions include:
1. `constructor(uint256 minDelay, address[] proposers, address[] executors)`
    - initializes contract with given `minDelay`, `proposers`, and `executors`
2. `receive()`
    - the contract might receive/hold ETH as part of maintenance process
3. `isOperation(bytes32 id) returns (bool pending)`
    - returns whether an `id` corresponds to a registered operation
    - includes both `pending`, `ready`, and `done` operations
4. `isOperationPending(bytes32 id) returns (bool pending)`
    - returns whether an operation is **pending or not**
5. `isOperationReady(bytes32 id) returns (bool ready)`
    - returns whether an operation is **ready or not**
6. `isOperationDone(bytes32 id) returns (bool done)`
    - returns whether an operation is **done or not**
7. `getTimestamp(bytes32 id) returns (uint256 timestamp)`
    - returns the `timestamp` at which an operation becomes `ready`
    - returns `0` for unset operations
    - returns `1` for `done` operations
8. `getMinDelay() returns (uin256 duration)`
    - returns the minimum delay for an operation to become valid.
    - can be changed by operations that call `updateDelay()`
9. `hashOperation(address target, uint256 value, bytes data, bytes32 predecessor, bytes32 salt) returns (bytes32 hash)`
    - returns the identifier of an operations containing a single transaction
10. `hashOperationBatch(address[] targets, uint256[] values, bytes32[] datas, bytes32, predecessor, bytes32 salt) returns (bytes32 hash)`
    - returns the identifier of an operation containing a batch of transactions
11. `schedule(address target, uint256 value, bytes data, bytes32 predecessor, bytes32 salt, uint256 delay)`
    - schedule an operation containing a single transaction
    - emits `CallScheduled` event
    - requires that the caller must have `proposer` role
12. `scheduleBatch(address[] targets, uint256[] values, bytes[]  datas, bytes32 predecessor, bytes32 salt, uint256 delay)`
    - schedule an operation containing a batch of transactions
    - emits one `CallScheduled` event per transaction
    - requires that caller must have `proposer` role
13. `cancel(bytes32 id)`
    - cancel an operation
    - requires that caller must have `proposer` role
14. `execute(address target, uint256 value, bytes data, bytes32 predecessor, bytes32 salt)`
    - execute a `ready` operation containing a single transaction
    - emits `CallExecuted` event
    - requires that the caller must have `executor` role
15. `executeBatch(address[] targets, uint256[] values, bytes[] datas, bytes32 predecessor, bytes32 salt)`
    - execute a `ready` operation containing a batch of transactions
    - emits one `CallExecuted` event per transaction
    - requires that caller must have `executor` role
16. `updateDelay(uint256 newDelay)`
    - changes minimum timelock duration for future operations
    - emits `MinDelayChange` event
    - requires that the caller must be the timelock itself
    - can only be achieved by scheduling and later executing an operation where the timelock is in the target and the data is the ABI-encoded call to this function

### 183. OZ ERC2771Context

A context variant for `ERC2771`.

`ERC2771` provides support for meta transactions, which are transactions that have been:
1. authorized by the transaction signer (signed by an EOA)
2. relayed by an untrusted third party that pays for the gas (the Gas Relay)

The problem is that, for a contract that is not natively aware of meta-transactions, the `msg.sender` of the `tx` will make it appear to be coming from the **Gas Relay** and not the **Transaction Signer**. A secure protocol for a contract to accept meta-transactions nees to prevent the **Gas Relay** from forging, modifying, or duplicating requirest by the **Transaction Signer.

The entities are:
1. **Transaction Signer**: entity that signs & sends the request to **Gas Relay**
2. **Gas Relay**: receives a signed request off-chain from **Transaction Signer** and pays gas to turn it into a valid `tx` that goes through **Trusted Forwarder**
3. **Trusted Forwarder**: a contract that is trusted by the **Recipient** to correctly verify the signature and nonce before forwarding the request to **Transaction Signer**
4. **Recipient**: a contract that can securely accept meta-transactions through a **Trusted Forwarder** by being compliant with this standard

### 184. OZ MinimalForwarder

Provides a simple minimal forwarder (described above) to be used together with an `ERC2771` compatible contract. It verifies the nonce and signature of the forwarded request before callling the destination contract.

Defines `struct ForwardRequest`:
```solidity
struct ForwardRequest {
    address from;
    address to;
    uint256 balue;
    uint256 gas;
    uint256 nonce;
    bytes data;
}
```

Functions include:
1. `verify(ForwardRequest calldata req, bytes calldata signature) public view returns (bool)`
2. `execute(ForwardRequest calldata req, bytes calldata signature) returns (bool success, returndata)`

### 185. OZ Proxy

This abstract contract provides a `fallback()` function that delegates all calls to another contract using the EVM instruction `DELEGATECALL`

We refer to the second contract as the implementation behind the proxy, and it has to be specified by overriding the virtual `_implementation` function.

Additionally, delegation to the implementation can be triggered manually through the `_fallback` function, or to a different contract through the `_delegate` function.

The success and return data of the delegated call will be returned back to the caller of the proxy.

1. `_delegate(address implementation)`
    - delegates the current call to implementation
    - function does not return to its internal call site, it will return directly to the external caller
2. `_implementation() returns (address)`
    - this is a virtual function that should be overridden so it returns the address to which the fallback function and `_fallback()` should delegate
3. `_fallback()`
    - delegates the current call to the address returned by `_implementation()`
    - this function does not return to its internal call site, it will return directly to the external caller
4. `fallback()`
    - fallback function that delegates calls to the address returned by `_implementation()`
    - will run if no other function in the contract matches the call data
5. `receive()`
    - fallback function that delegates calls to the address returned by `_implementation()`
    - will run if call data is empty
6. `_beforeFallback()`
    - hook that is called before falling back to the implementation
    - can happen as part of a manual `_fallback()` call, or as part of the Solidity `fallback()` or `receive()` functions
    - if overridden, should call `super._beforeFallback()`

### 186. OZ ERC1967Proxy

Implements an upgradable proxy.

The proxy is upgradable because calls are delegated to an implementation address that can be changed.

The address is stored in `storage` location specified by `EIP1967`, so that does not conflict with the storage layout of the implementation behind the proxy.

Upgradeability is only provided internally through `_upgradeTo`.

### 187. OZ TransparentUpgradableProxy

Implements a proxy that is upgradable by an admin.

To avoid proxy selector clashing, which can potentially be used in an attack, this contract uses the transparent proxy pattern.

This pattern implies two things that go hand in hand:
1. If any account other than admin calls the proxy, the call will be forwarded to the implementation, even if the call matches one of the admin function exposed by the proxy itself
2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the implementation. If the admin tries to call a function on the implementation it will fail with an error that says "admin cannot fallback to proxy target."

These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due to sudden errors when trying to call a function from the proxy implementation.

1. `constructor(address _logic, address admin_, bytes _data)`
    - initializes an upgradable proxy managed by `_admin`
    - backed by the implementation at `_logic`
    - optionally initialized with `_data`
2. `admin() returns (address admin_)`
    - returns the current admin
3. `implementation() returns (address implementation_)`
    - returns the current implementation
4. `changeAdmin(address newAdmin)`
    - changes the admin of the proxy
    - emits an `AdminChanged` event
5. `upgradeTo(address newAdmin)`
    - upgrade the implementation of the proxy
6. `upgradeToAndCall(address newImplementation, bytes data)`
    - upgrade the implementation of the proxy
    - then calls a function from the new implementation as specified by data, which should be an encoded function call
    - useful to initialize new storage-variables in the proxied contract
7. `_admin() returns (address adm)`
    - returns the current admin
8. `_beforeFallback()`
    - makes sure the admin cannot access the fallback function

### 188. OZ ProxyAdmin

This is an auxiliary contract meant to be assigned as the admin of a `TransparentUpgradableProxy`
1. `getProxyImplementation(contract TransparentUpgradableProxy proxy) returns (address)`
    - returns the current implementation of proxy
    - requires that this contract be the admin of proxy
2. `getProxyAdmin(contract TransparentUpgradableProxy proxy) returns (address)`
    - returns current admin of proxy
    - requires that this contract be the admin of proxy
3. `changeProxyAdmin(contract TranparentUpgradableProxy proxy, address newAdmin)`
    - changes the admin of proxy to newAdmin
    - requires that this contract must be the current admin of proxy
4. `upgrade(contract TransparentUpgradeableProxy proxy, address implementation, bytes data)`
    - upgrades proxy to implementation
    - requires that this contract must be the admin of proxy
5. `upgradeAndCall(contract TransparentUpgradableProxy proxy, address implementation, bytes data)`
    - upgrades proxy to implementation and calls a function on the new implementation
    - requires that this contract must be the admin of proxy

### 189. OZ BeaconProxy

Implements a proxy that gets the implementation address for each call from a `UpgradableBeacon`

The beacon address is stored in storage slot `uint(keccack256('eip1967.proxy.beacon'))-1`, so that it doesn't conflict with the storage layout of the implementation behind the proxy.

1. `constructor(address beacon, bytes data)`
    - initializes the proxy with beacon
    - if data is not empty, it is used as data in a delegate call to the implementation returned by the beacon
    - this will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.
    - requires that beacon must be a contract with the interface `IBeacon`
2. `_beacon() returns (address beacon)`
    - returns the current beacon address
3. `_implementation() returns (address)`
    - returns the current implementation address of the associated beacon
4. `_setBeacon(address beacon, bytes data)`
    - changes the proxy to use a new beacon
    - if data is nonempty, it is used as data in a delegate call to the implementation returned by the beacon
    - requires that:
        1. beacon must be a contract
        2. the implementation returned by beacon must be a contract

### 190. OZ UpgradableBeacon

Is used in conjuction with one or more instances of `BeaconProxy` to determine their implementation contract, which is where they will delegate all function calls.

An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.

1. `constructor(address implementation_)`
    - sets the address of the initial implementation, as well as the deployer account as the owner who can upgrade the beacon
2. `implementation() returns (address)`
    - returns the current implmentation address
3. `upgradeTo(address newImplementation)`
    - upgrades the beacon to a new implementation
    - emits `Upgraded` event
    - requires that:
        1. `msg.sender` must be the owner of the contract
        2. `newImplementation` must be a contract

### 191. OZ Clones

`EIP1167` is a standard for deploying minimal proxy contract, also known as "clones."

To simply and cheaply clone contract functionality in an immutable way, this standard specifies a minimal bytecode implementation that delegates all calls to a known, fixed address.

The library includes functions to deploy a proxy using either create (traditional deployment) or `CREATE2` (salted deterministic deployment).

It also includes function to predict the addresses of clones deployed using the deterministic method.

Functions include:
1. `clone(address implementation) returns (address instance)`
    - deploys and returns the address of a clone that mimics the behaviour of implementation
    - function uses `CREATE` opcode, which should never revert
2. `cloneDeterministic(address implementation, bytes32 salt) returns (address instance)`
    - deploys and returns the address of a clone that mimics the behaviour of implementation
    - this function uses the `CREATE2` opcode and a salt to deterministically deploy the clone
    - using the same implementation and salt multiple times will revert, since the clones cannot be deployed twice at the same address
3. `predictDeterministicAddress(address implementation, bytes32 salt, address deployer) returns (address predicted)`
    - computes the address of a clone deployed using `Clones.cloneDeterministic`
4. `predictDeterministicAddress(address implementation, bytes32 salt) returns (address predicted)`
    - computes the address of a clone deployed using `Clones.cloneDeterministic`

### 192. OZ Initializable

Aids in writing upgradable contracts, or any kind of contract that will be deployed behind a proxy.

Since a proxied contract cannot have a constructor, it is common to move constructor logic to an external initializer function ,usually called **initialize**. It then becomes necessary to protect this initializer function so that it can only be called once. The initializer modifier provided by this contract will have this effect.

To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as possible by providing the encoded function call as the `_data` argument.  When used with inheritance, manual care must be taken not to invoke a parent initializer twice, or to ensure that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
