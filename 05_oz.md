## 147. OpenZeppelin Libraries

OpenZeppelin's smart contract libraries are perhaps the most commonly used libraries in smart contract projects. These include contracts for popular token standards, access control, security, safe math, proxies, and other utilities.

### 148. OZ ERC20

Implements the popular ERC20 token standards.

Its functions include:
1. `constructor(string name_, string symbol_)`
    - sets values for `name_` and `symbol_`. To select a different value for decimals you should overload it. All three of these values are immutable; they can only be set once during construction.
2. `name() returns (string)`
    - returns the name of the token
3. `symbol() returns (string)`
    - returns the symbol of the token, usually a shorter version of the name
4. `decimals() returns (uint8)`
    - returns the number of decimals used to get its user representation.
    - ff `decimals()` is `2`, a balance of `505` tokens is displayed to the user as `5.05` ( 505 / 10**2 )
    - usually set to `18`, mirroring `ether` and `wei`, unless overridden
5. `totalSupply()`
    - returns the amount of tokens in existence
6. `balanceOf(address account) returns (uint256)`
    - returns the amount of tokens owned by an account
7. `transfer(address recipient, uint256 amount) returns (bool)`
    - moves amount tokens from the caller's account to recipient.    
    - Returns a boolean value indicating whether the operation succeeded.
    - Emits a `Transfer` event.
8. `allowance(address owner, address spender) returns (uint256)`
    - returns the remaining number of tokens that *spender* will be allowed to spend on behalf of *owner* through `transferFrom()`
    - set to `0` by default
    - increased via `approve()`
    - decreased when`tranferFrom()` spends owner's tokens
9. `approve(address spender, uint256 amount)`
    - sets *amount* as the *allowance* of *spender* over the caller's tokens.
    - returns `bool` success condition
    - emits `Approval` event
    - WARNING: changing an allowance brings risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this *race condition* is to first reduce the spender's allowance to `0` and set the desired value afterwards.
10. `transferFrom(address spender, uint256 recipient, uint256 amount) returns (bool)`
   - moves *amount* of tokens from *spender* to *recipient*.
   - requires that the caller has sufficient *allowance* to spend *spender's* tokens
   - *amount* is deducted from the caller's *allowance*
   - returns `bool` success condition
   - emits `Transfer` event
11. `increaseAllowance(address spender, uint256 addedValue) returns (bool)`
    - atomically increases *allowance* granted to *spender* by the caller
    - alternative to `approve()`, used to mitigate *race condition* warned above
    - emits `Approval` event indicating the updated *allowance*
    - requires that `spender != address(0)`
12. `decreaseAllowance(address spender, uint256 subtractedValue) returns (bool)`
    - atomically decreases the *allowance* granted to spender by the caller
    - alternative to `approve()`, used to mitigate *race condition* warned above
    - emits `Approval` event indicating updated *allowance*
    - requires that:
         1. `spender != address(0)`
         2. `allowance[spender] >= subtractedValue`

The different extensions and presets are:
1. `ERC20Burnable`
    - extension of `ERC20` that allows token holders to destroy both their own tokens, and those they have an allowance for, in a way that can be recognized off-chain (via `event` analysis)
2. `ERC20Capped`
    - extension of `ERC20` that adds a cap to the supply of tokens and enforces it in the `mint()` function
3. `ERC20Pausable`
    - extension of `ERC20` that may pause token `transfer()`, `mint()`, and `burn()`
4. `ERC20Snapshot`
    - extension of `ERC20` adding a snapshot mechanism
    - when a snapshot is created, the balances and total supply are recorded for later access
    - used to safely create mechanism based on balances, such as trustless dividends or weighted voting
    - the internal `_snapshot()` function creates a snapshot,    
        - emits `Snapshot(uint id)` event
        - returns `currentId`
    - use `totalSupplyAt(uint snapshotId)` to get the total supply at the time of a snapshot
    - use `balanceOfAt(address account, uint snapshotId)` to get the balance of a particular address
5. `ERC20PresetFixedSupply`
    - extension of `ERC20` adding:
        1. a pre-minted `initialSupply`
        2. ability for holders to `burn()` their tokens
        3. no access control mechanism (for minting/pausing) and hence no governance
    - uses `ERC20Burnable` to include burn capabilities
6. `ERC20PresetMinterPauser`
    - extension of `ERC20` adding:
        1. ability for holders to `burn()` their tokens
        2. `MINTER_ROLE` allows for token minting
        3. `PAUSER_ROLE` can stop all token transfers
        4. `DEFAULT_ADMIN_ROLE` may grant both minter and pauser roles to other accounts
    - uses `AccessControl` contract to lock permissioned functions to different roles
    - the account that deploys the contract is granted with all role permissions: minter, pauser, and admin

### 149. OZ SafeERC20

Wrappers around `ERC20` operations that throw an `Error` on failure when the token contract implementation returns `false`.

Tokens that return no value and instead revert or throw on failure are also supported, with non-reverting calls that are assumed to be successful.

Adds functions:
1. `safeTransfer()`
2. `safeTransferFrom()`
3. `safeApprove()`
4. `safeDecreaseAllowance()`
5. `safeIncreaseAllowance()`

### 150. OZ TokenTimelock

A token holder contract that will allow a beneficiary to extract the tokens after a given release time. Useful for simple vesting schedules like "advisors get all their tokens after 1 year."

### 151. OZ ERC721

Implements the popular `ERC721` Non-fungible tokens standard.

Its functions include:
1. `balanceOf(address owner) returns (uin256 balance)`
    - returns the number of tokens in the owner's account
2. `ownerOf(uint256 tokenId) returns (address owner)`
    - returns the owner of the `tokenId` token
    - requires that `tokenId` does exist
3. `transferFrom(address from, address to, uint256 tokenId)`
    - transfers `tokenId` token from `from` to `to`
    - requires that:
        - `from != address(0)`
        - `to != address(0)`
        - `ownerOf(tokenId) == from`
        - if the caller is not `from`, then `tokenId` must be *approved* via either `approve()` or `setApproveForAll()`
    - emits `Transfer` event
4. `safeTransferFrom(address from, address to, uint256 tokenId)`
    - same as `transferFrom()` with additional checks.
    - first checks that contract recipients are aware of the `ERC721` protocol to prevent tokens from being forever locked.
    - additional requirement: if `to` is a contract account, it must implement `IERC721Receiver.onERC721Received()`, which is called upon a safe transfer.
5. `approve(address to, uint256 tokenId)`
    - gives permission to account `to` to `transfer()` a token with `tokenId` to another account
    - approval is cleared when the token is transferred
    - only a single account can be approved at a time, so approving the zero address clears previous approvals
    - requires that:
        - caller must own the token or be *approved*
        - `tokenId` must exist
    - emits `Approval` event
6. `getApproved(uint256 tokenId) returns (address operator)`
    - returns the account approved for `tokenId` token
    - requires that `tokenId` exists
7. `setApprovalForAll(address operator, bool _approved)`
    - approve or remove `operator` as an operator for the caller
    - operators may call `transferFrom()` or `safeTransferFrom()` for any token owned by the caller
    - requires that `operator` is not the caller
    - emits `ApprovedForAll` event
8. `isApprovedForAll(address owner, address operator) returns (bool)`
    - returns `true` if the `operator` is allowed to manage all the assets of the `owner`

The different extensions include:
1. `ERC721Burnable`
    - extension enabling holders to `burn()` tokens
2. `ERC721Enumerable`
    - extension enabling *enumerability* of all token ids in the contract, as well as all token ids owned by each account
3. `ERC721Pausable`
    - extension enabling an admin to *pause* token transfers, minting, and burning
    - useful for scenarios such as preventing trades until the end of an evaluation period, or having an emergency "off" switch in the event of a large bug
4. `ERC721URIStorage`
    - extension enabling storage based token URI management
5. `ERC721PresetMinterPauserAutoId`
    - extension enabling:
        1. ability for holders to `burn()` their tokens
        2. `MINTER_ROLE` allows for token minting
        3. `PAUSER_ROLE` may pause all token transfers
        4. `DEFAULT_ADMIN_ROLE` may grant minter and pauser roles to other accounts
        5. `tokenId` and URI autogeneration
    - uses `AccessControl` to lock permissioned functions using the different roles
    - the account that deploys the contract will be granted the minter, pauser, and admin roles
6. `ERC721Holder`
    - implementation of `IERC721Reciever` interface
    - accepts all token transfers

### 152. OZ ERC777

`ERC777` is similar to `ERC20` in that it defines a standard for fungible tokens.

`ERC777` is backwards compatible with `ERC20` and contains additional improvements including:
- getting rid of confusion around *decimals*
- minting and burning with proper *events*
- receive hooks (the killer feature)

1. A *hook* is a function in a contract that is called when tokens are sent to it, meaning accounts and contracts can *react* to receiving tokens. This enables several use cases including:
    - atomic purchases using tokens (no need for `approve()` and `transferFrom()` in two separate transactions)
    - rejecting reception of tokens (revert on the hook call)
    - redirecting the received tokens to other addresses
2. Both contracts and regular addresses can control and reject which token they send by registering a `tokensToSender` hook (reject by reverting in the hook function)
3. Both contracts and regular addresses can control and reject which token they receive by registering a `tokensReceived` hook (reject by reverting in the hook function)
4. The `tokensReceived` hook allows to send tokens to a contract and notify it in a single transaction, unlike `ERC20` with requires a double call (`approve()` and `transferFrom()` to achieve this)
5. Furthermore, since contracts are required to implement these hooks in order to receive tokens, no tokens can get stuck in a contract that is unaware of the `ERC777` protocol, as has happend countless times when using `ERC20` tokens
6. It mandates that `decimals()` always return `18`, so there is no need for the developer to set it.
7. Has a concept of `defaultOperators` which are special accounts (usually other smart contracts) that will be able to transfer tokens on behalf of their holders
8. Implements `send()` (besides `trnasfer()`) where if the recipient contract has not registered itself as aware of the `ERC777` protocol, then transfers to it are disabled to prevent tokens from being locked forever. Accounts can be notified of tokens being sent to them by having a contract implement this `IERC777Recipient` interface and registering it on the `ERC1820` global registry.

### 153. OZ ERC1155

`ERC1155` is a novel token standard that aims to take the best from previous standards to create a fungibility-agnostic and gas-efficient token contract
1. uses a single smart contract to represent multiple tokens
2. accounts have distinct balance for each token id, and non-fungible tokens are implemented by simply minting a single one of them
3. this approach leads to massive gas savings for project requiring multiple tokens. Instead of deploying a new contract for each token type, a single `ERC1155` token contract can hold the entire system state, reducing both deployment costs and complexity
4. Because all state is held in a single contract, it is possible to operate over multiple tokens in a single transaction very efficiently. The standard provides two functions, `balanceOfBatch()` and `safeBatchTransferFrom()`, that make querying multiple balances and transfering multiple tokens simpler and less gas-intensive

### 154. OZ Ownable

Provides basic access control mechanism in which there is an account `owner` that can be granted exclusive access to specific functions.
- By default, the `owner` will be the account that deploys the contract.
- `owner` can be changed via `transferOwnership(address newOwner)`
- The module is used through inheritance
- It makes the modifier `onlyOwner` available to restrict their use to the `owner`

### 155. OZ AccessControl

Provides a general role based access control mechanism
- multiple hierarchical roles can be created and assigned each to multiple Accounts
- roles can be used to represent a set of permissions
- `hasRole` is used to restrict access to a function call
- roles can be granted and revoked dynamically via the `grantRole` and `revokeRole` functions which can only be called by the role's associated admin accounts

While the simplicity of `Ownable` is useful for simple systems or quick prototyping, different levels of authorization are often needed via `AccessControl`.

You may want for an account to have permission to ban users from a system, but not create new tokens. Role-Based Access Control (RBAC) offers flexibility in this regard.

We will effectively be defining multiple roles, each allowed to perform different sets of actions.

An account may have, for example, "moderator", "minter", or "admin" roles, which can each be checked for. Separately, you will be able to define rules for how accounts can be granted a role, have it revoked, and more.

`AccessControlEnumerable` extends `AccessControl`, allowing enumerating the members of each role.

### 156. OZ Pausable

Provides an emergency stop mechanism using functions `pause()` and `unpause()` that can be triggered by an authorized account.
- used through inheritance.
- makes available modifiers `whenNotPaused` and `whenPaused`
- only the functions using these modifiers are affected when contract is paused or unpaused.

### 157. OZ ReentrancyGuard

Prevents reentrant calls to a functions.
- used through inheritance
- makes `nonReentrant` modifier available
- functions with this modifier will revert upon receiving a nested (reentrant) call

### 158. OZ PullPayment

Provides a pull-payment strategy, where the paying contract doesn't invoke any functions on the receiver account, which must withdraw its payments itself.
- considered a best practice for sending Ether, security wise
- prevents recipients from blocking execution
- eliminates reentrancy concerns

### 159. OZ Address

The `Address` library is a collection of functions related to the `address` type:
1. `isContract(address account) returns (bool)`
    - returns `true` if account is a `contract`
    - unsafe to assume that an `address` returning `false` is an EOA (not a contract)
    - among others, returns `false` for:
        1. an EOA
        2. contract in construction
        3. address where a contract will be created
        4. address where contract lived, but was destroyed
2. `sendValue(address payable recipient, uint256 amount)`
    - replacement for solidity's `transfer()`
    - sends `amount` of wei to recipient, forwarding all available gas and reverting on errors
    - EIP1884 increases the gas cost of certain opcodes, possibly making contracts go over the 2300 gas limit imposed by transfer, making them unable to receive funds via `tansfer()`
    - `sendValue` removes the limitation noted above
3. `functionCall(address target, bytes data) returns (bytes)`
    - low-level function `call`
    - A plain `call` is an unsafe replacement for a function call: use this function instead.
    - if the target function reverts with a revert reason, it is bubbled up by this function (like regular function calls)
    - returns raw returned data
    - requires that target must be a contract and that calling target with data must not revert
4. `functionCallWithValue(address target, bytes data, uint256 value) returns (bytes)`
    - same as functionCall, but also transferring value wei to target
    - requires that:
        1. the calling contract must have an ETH balance of at least value
        2. called function must be `payable`
5. `functionStaticCall(address target, bytes data) returns (bytes)`
    - same as `functionCall()` but performing a static call
6. `functionDelegateCall(address target, bytes data) returns (bytes)`
    - same as `functionCall()` but performing a delegate call

The above `functionCall*` function have variants which pass an `errorMessage` parameter that specifies the fallback `revert` reason when the target reverts.

### 160. OZ Arrays

Collection of functions related to array types.
- `findUpperBound(uint[] array, uint element) returns (uint)`
    - seaches a sorted `array` and returns the first index containing a value greater than or equal to `element`
    - if no such index exists, the array `length` is returned
    - time complexity: O(log n)
    - `array` must be sorted in *ascending order* and contain *no repeated elements*

### 161. OZ Context

Provides information about the current execution context, including the sender of a transaction and its data.
- These are generally available via `msg.sender` and `msg.data`, they should not be accessed directly.
- Dealing with meta-transactions, the account sending and paying for execution may not be the actual sender (as far as an application is concerned)
- Only required for intermediate, library-like contracts

### 162. OZ Counters

Provides counters that can only be incremented or decremented by one.
- used to track the number of elements in a mapping, issuing ERC721 ids, or counting request ids.
- functions are:
    1. `current(struct Counters.Counter counter) returns (uint)`
    2. `increment(struct Counters.Counter counter)`
    3. `decrement(struct Counters.Counter counter)`

### 163. OZ Create2

Makes use of `CREATE2` EVM opcode easier and safer. `CREATE2` can be used to compute the address where a smart contract will be deployed in advance, allowing for new mechanisms known as *counterfactual interactions*
1. `deploy(uint amount, bytes32 salt, bytes bytecode) returns (address)`
    - deploys a contract using `CREATE2`
    - address of deployment can be known in advance via `computeAddress()`
    - bytecode for contract can be obtained with `type(contractName).creationCode`
    - requires that:
        - `bytecode` is not empty
        - `salt` must have not been used for `bytecode` already
        - *factory* must have a balance of at least `amount`
        - if `amount` is non-zero, `bytecode` must have a `payable` constructor
2. `computeAddress(bytes32 salt, bytes32 bytecodeHash) returns (address)`
    - returns the `address` where a `contract` will be stored if deployed via `deploy()`
    - any change in `bytecodeHash` or `salt` results in a new destination address
3. `computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) returns (address)`
    - returns the `address` where a `contract` will be stored if deployed via `deploy()` from a contract located at `deployer`
    - if the `deployer` is this contract's address, it returns the same value as the `computeAddress()` method above

### 164. OZ Multicall

Provides a function to batch together multiple calls in a single external call.
1. `multicall(bytes[] calldata data) external returns (bytes[])`
    - receives and executes a batch of function calls on this contract

### 165. OZ Strings

String operations:
1. `toString(uint value) returns (string)`
    - converts a `uint256` to its ASCII `string` decimal representation
2. `toHexString(uint value) returns (string)`
    - converts a `uint256` to its ASCII `string` hexadecimal representation
3. `toHexString(uint value, uint length) returns (string)`
    - converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length

### 166. OZ ECDSA

Provides functions for recovering and managing Etherum account ECDSA signatures.

These are often generated via `web3.eth.sign` and are a 65 byte array (of type `bytes` in Solidity) arranged the following way: `[ [v(1)], [r(32)], [s(32)] ]`

The data signer can be recovered with `ECDSA.recover`, and its `address` compared to verify the signature.

Most wallets will hash the data to sign and add the prefix `\x19Ethereum Signed Message:\n`, so when attempting to recover the signer of an Ethereum signed message hash, you'll want to use `toEthSignedMessageHash`

The `ecrecover` EVM opcode allows for malleable (non-unique) signatures. **This library prevents this by requiring `s` value to be in the lower half order, and the `v` value to either be  `27` or `28`

### 167. OZ MerkleProof

Deals with verification of Merkle Trees proofs
1. `verify()`
    - can prove that some value is part of a merkle tree
    - returns `true` if a "leaf" can be proved to be a part of a Merkle tree defined by "root"; a "proof" must be provided containing sibling hashes on the branch from the leaf to the root of the tree.
    - each pair of leaves and each pair of pre-images are assumed to be sorted.

### 168. OZ SignatureChecker

Provides a single mechanism to verify both private-key (EOA) ECDSA signature and ERC1271 contract signatures.

Using this instead of `ECDSA.recover` in your contract will make them compaticle with smart contract wallets such as Argent and Gnosis.

...

### 169. OZ EIP712

### 170. OZ Escrow

### 171. OZ ConditionalEscrow

### 172. OZ RefundEscrow

### 173. OZ ERC165

### 174. OZ Math

### 175. OZ SafeMath

### 176. OZ SignedSafeMath

### 177. OZ SafeCast

### 178. OZ EnumerableMap

### 179. OZ EnumerableSet

### 180. OZ BitMaps

### 181. OZ PaymentSplitter

### 182. OZ TimelockController

### 183. OZ ERC2771Context

### 184. OZ MinimalForwarder

### 185. OZ Proxy

### 186. OZ ERC1967Proxy

### 187. OZ TransparentUpgradableProxy

### 188. OZ ProxyAdmin

### 189. OZ BeaconProxy

### 190. OZ UpgradableBeacon

### 191. OZ Clones

### 192. OZ Initializable
